import * as Realm from "realm-web";
import * as utils from "./utils";

// The Worker's environment bindings. See `wrangler.toml` file.
interface Bindings {
	// MongoDB Realm Application ID
	REALM_APPID: string;
}

// Define type alias; available via `realm-web`
type Document = globalThis.Realm.Services.MongoDB.Document;


let App: Realm.App;
const ObjectId = Realm.BSON.ObjectID;

// Define the Worker logic
const worker: ExportedHandler<Bindings> = {
	async fetch(req, env) {
		const url = new URL(req.url);
		App = App || new Realm.App(env.REALM_APPID);

		const method = req.method;
		const path = url.pathname.replace(/[/]$/, "");
		const todoID = url.searchParams.get("id") || "";
		if (path !== "/api/randomfood") {
			return utils.toError(`Unknown "${path}" URL; try "/api/randomfood" instead.`, 404);
		}

		const token = req.headers.get("authorization");
		if (!token)
			return utils.toError(
				'Missing "authorization" header; try to add the header "authorization: REALM_API_KEY".',
				401
			);

		try {
			const credentials = Realm.Credentials.apiKey(token);
			// Attempt to authenticate
			var user = await App.logIn(credentials);
			var client = user.mongoClient("mongodb-atlas");
		} catch (err) {
			return utils.toError("Error with authentication.", 500);
		}

		// Grab a reference to the "cloudflare.todos" collection
		const collection_credit = client.db("randomfood").collection("creditdatabase");

		try {
			if (method === "GET") {
				if (todoID) {
					// GET /api/todos?id=XXX
					return utils.reply(
						await collection_credit.findOne({
							_id: new ObjectId(todoID),
						})
					);
				}

				// GET /api/todos
				return utils.reply(await collection_credit.find());
			}

			// POST /api/todos
			if (method === "POST") {
                let data = {}
				data = await req.json();
                console.log(data);
				return utils.reply(await collection_credit.insertOne(data));
			}

			// PATCH /api/todos?id=XXX&done=true
			if (method === "PATCH") {
				return utils.reply(
					await collection_credit.updateOne(
						{
							_id: new ObjectId(todoID),
						},
						{
							$set: {
								done: url.searchParams.get("done") === "true",
							},
						}
					)
				);
			}

			// DELETE /api/todos?id=XXX
			if (method === "DELETE") {
				return utils.reply(
					await collection_credit.deleteOne({
						_id: new ObjectId(todoID),
					})
				);
			}

			// unknown method
			return utils.toError("Method not allowed.", 405);
		} catch (err) {
			const msg = (err as Error).message || "Error with query.";
			return utils.toError(msg, 500);
		}
	},
};

// Export for discoverability
export default worker;
